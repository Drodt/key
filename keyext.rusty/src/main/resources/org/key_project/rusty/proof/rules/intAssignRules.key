/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/**
    This file contains all rules moving an integer related assignment
    from the inside of a modality to the logic (as an update). The
    Rust operators are therefore mapped to their generic logic
    function. These generic functions (rust...) are later interpreted
    as mathematical function dependent on the chosen Rust semantics.

    See intRules.key for an overview of the integer files.
*/

\schemaVariables {
    \modalOperator {diamond, box} #allmodal;

    \program SimpleExpression se, se0, se1;
    \program RustU8Expression seu8, seu80, seu81;
    \program RustU16Expression seu16, seu160, seu161;
    \program RustU32Expression seu32, seu320, seu321;
    \program RustU64Expression seu64, seu640, seu641;
    \program RustU128Expression seu128, seu1280, seu1281;
    \program RustUsizeExpression seusize, seusize, seusize;

    \program RustI32Expression sei32, sei320, sei321;

    \program Variable loc;

    \formula post;
}

\rules {
    // ------------------------------------------------------------------------
    // ----------- Rules for binary arithmetic operators
    // ------------------------------------------------------------------------

    // ------------- multiplication

    assignmentMultiplicationU32 {
        \find(\modality{#allmodal}{c#
                s#loc = s#seu320 * s#seu321
            #c}\endmodality (post))
        \sameUpdateLevel
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> in_u32(mul(seu320, seu321)))
        };
        \replacewith({loc := mul(seu320, seu321)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "multiplication"
    };

    // ------------- subtraction

    assignmentSubtractionU32 {
        \find(\modality{#allmodal}{c#
                s#loc = s#seu320 - s#seu321
            #c}\endmodality (post))
        \sameUpdateLevel
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> in_u32(sub(seu320, seu321)))
        };
        \replacewith({loc := sub(seu320, seu321)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    assignmentSubtractionU64 {
        \find(\modality{#allmodal}{c#
                s#loc = s#seu640 - s#seu641
            #c}\endmodality (post))
        \sameUpdateLevel
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> in_u64(sub(seu640, seu641)))
        };
        \replacewith({loc := sub(seu640, seu641)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    assignmentSubtractionI32 {
        \find(\modality{#allmodal}{c#
                s#loc = s#sei320 - s#sei321
            #c}\endmodality (post))
        \sameUpdateLevel
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> in_i32(sub(sei320, sei321)))
        };
        \replacewith({loc := sub(sei320, sei321)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "subtraction"
    };

    // ------------- addition

    assignmentAdditionU32 {
        \find(\modality{#allmodal}{c#
                s#loc = s#seu320 + s#seu321
            #c}\endmodality (post))
        \sameUpdateLevel
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> in_u32(add(seu320, seu321)))
        };
        \replacewith({loc := add(seu320, seu321)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    assignmentAdditionU64 {
        \find(\modality{#allmodal}{c#
                s#loc = s#seu640 + s#seu641
            #c}\endmodality (post))
        \sameUpdateLevel
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> in_u64(add(seu640, seu641)))
        };
        \replacewith({loc := add(seu640, seu641)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };

    assignmentAdditionI32 {
        \find(\modality{#allmodal}{c#
                s#loc = s#sei320 + s#sei321
            #c}\endmodality (post))
        \sameUpdateLevel
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> in_i32(add(sei320, sei321)))
        };
        \replacewith({loc := add(sei320, sei321)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "addition"
    };
}

\rules(panics:ignore) {
    assignmentDivisionU32 {
        \find(\modality{#allmodal}{c#
                s#loc = s#seu320 / s#seu321
            #c}\endmodality (post))
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> !(seu320 = u32_MIN & seu321 = -1))
        };
        \replacewith({loc := rdiv(seu320, seu321)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };
}

\rules(panics:allow) {
    assignmentDivisionU32 {
        \find(\modality{#allmodal}{c#
                s#loc = s#seu320 / s#seu321
            #c}\endmodality (post))
        (intRules:rustSemantics) {
            "Overflow check":
                \add(==> !(seu320 = u32_MIN & seu321 = -1))
        };
        \replacewith(\if(seu321 != 0) \then({loc := rdiv(seu320, seu321)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \else (\modality{#allmodal}{c# panic!() #c}\endmodality (post))) // TODO: panic message
        \heuristics(executeIntegerAssignment)
        \displayname "division"
    };
}
