/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

 // --------------- loops ------------------------------------------------------//
\schemaVariables {
    \modalOperator {diamond, box} #allmodal;
    \modalOperator {diamond} #dia;
    \modalOperator {box} #box;
    \formula post;

    \program SimpleExpression se;
    \program LeftHandSide lhs;
    \program BlockExpression body;
    \program [list] Statement slist;
    \program Expression nse;
    \program Label lb, lb1;

    \program Variable x;
}

/////////////////////////////////////////////////////
// Rules transforming loops: Invariant & Unwinding //
/////////////////////////////////////////////////////

\rules(programRules:Rust) {
    loopScopeInvDia {
        \schemaVar \formula inv;
        \schemaVar \term any variantTerm;
        \schemaVar \formula loopFormula;
        \schemaVar \program Expression loopExpr;
        \schemaVar \program Variable variant;

        \schemaVar \program [list] Statement localVarDeclsBefore_LOOP;
        \schemaVar \update updateBefore_LOOP;
        \schemaVar \update updateFrame_LOOP;

        \find((\modality{diamond} {c# loop s#body #c}\endmodality (post)))

        \varcond(\new(x, bool))
        \varcond(\new(variant, any))
        \varcond(\newLocalVars(localVarDeclsBefore_LOOP, updateBefore_LOOP, updateFrame_LOOP, body))

        \varcond(\storeTermIn(loopFormula, \modality{diamond}{ loop s#body }\endmodality (post)))
        // Implementation Note (DS, 2019-04-11): We have to separately store the active statement
        //   in a ProgramSV (and cannot just use the loopFormula already stored above) for the
        //   varconds below since otherwise, we get an error because KeY cannot compute the Taclet
        //   Prefix for loopFormula. It's obviously not possible (at least not without a change to
        //   something deep inside the KeY core which I don't dare to do now) to instantiate an
        //   unmatched TermSV in a varcond and use it in subsequent varconds. We could of course also
        //   just always pass the whole input formula, but that is also not really nice and handy.
        \varcond(\storeExprIn(loopExpr, \modality{diamond}{ loop s#body }\endmodality (post)))
        \varcond(\hasInvariant(loopExpr, #dia))
        \varcond(\getInvariant(loopExpr, #dia, inv))
        \varcond(\getVariant(loopExpr, variantTerm))

        "Invariant Initially Valid":
            \replacewith(inv);

        "Invariant Preserved and Used":
            \replacewith(
              \modality{diamond}{
                    let s#variant : s#typeof(s#variant);
                    s#localVarDeclsBefore_LOOP
              }\endmodality (
                {updateBefore_LOOP
                    || #createLocalAnonUpdate(loopFormula)}
                {variant := variantTerm}
                (inv ->
                    (\modality{diamond}{c#
                              let s#x : bool;
                              loop_scope!(s#x, {
                                s#body
                                continue;
                              })
                              #c}\endmodality (
                            (x = TRUE -> post) &
                            (x = FALSE ->
                                inv
                                & {updateFrame_LOOP} #createFrameCond(loopFormula)
                                & prec(variantTerm, variant))
                        )))
              )
            )

        \heuristics(loop_scope_inv)
    };

    loopScopeInvBox {
        \schemaVar \formula inv;
        \schemaVar \formula loopFormula;
        \schemaVar \program Expression loopExpr;

        \schemaVar \program [list] Statement localVarDeclsBefore_LOOP;
        \schemaVar \update updateBefore_LOOP;
        \schemaVar \update updateFrame_LOOP;

        \find((\modality{box} {c# loop s#body #c}\endmodality (post)))

        \varcond(\new(x, bool))
        \varcond(\newLocalVars(localVarDeclsBefore_LOOP, updateBefore_LOOP, updateFrame_LOOP, body))

        \varcond(\storeTermIn(loopFormula, \modality{diamond}{ loop s#body }\endmodality (post)))
        // Implementation Note (DS, 2019-04-11): We have to separately store the active statement
        //   in a ProgramSV (and cannot just use the loopFormula already stored above) for the
        //   varconds below since otherwise, we get an error because KeY cannot compute the Taclet
        //   Prefix for loopFormula. It's obviously not possible (at least not without a change to
        //   something deep inside the KeY core which I don't dare to do now) to instantiate an
        //   unmatched TermSV in a varcond and use it in subsequent varconds. We could of course also
        //   just always pass the whole input formula, but that is also not really nice and handy.
        \varcond(\storeExprIn(loopExpr, \modality{diamond}{ loop s#body }\endmodality (post)))
        \varcond(\hasInvariant(loopExpr, #dia))
        \varcond(\getInvariant(loopExpr, #dia, inv))

        "Invariant Initially Valid":
            \replacewith(inv);

        "Invariant Preserved and Used":
            \replacewith(
              \modality{diamond}{
                    s#localVarDeclsBefore_LOOP
              }\endmodality (
                {updateBefore_LOOP
                    || #createLocalAnonUpdate(loopFormula)}
                (inv ->
                    (\modality{diamond}{c#
                              let s#x : bool;
                              loop_scope!(s#x, {
                                s#body
                                continue;
                              })
                              #c}\endmodality (
                            (x = TRUE -> post) &
                            (x = FALSE ->
                                inv
                                & {updateFrame_LOOP} #createFrameCond(loopFormula))
                        )))
              )
            )

        \heuristics(loop_scope_inv)
    };

    /*unwindLoopScope {
        \find((\modality{#allmodal} {c# loop s#body #c}\endmodality (post)))

        \varcond(\new(x, bool))

        \replacewith(
            (\modality{#allmodal} {c#
                       let s#x : bool;
                       loop_scope!(s#x, {
                         s#body
                         continue;
                       })
                    #c}
                     \endmodality (
                    (x = TRUE -> post) &
                    (x = FALSE ->
                        (\modality{#allmodal} {c#
                                   #reattachLoopInvariant(loop s#body);
                                #c}\endmodality (post)))
                )
            )
        )

        \heuristics(loop_scope_expand)
    };*/

    ////////////////////////////////
    // Rules Handling Loop Scopes //
    ////////////////////////////////

    lsBreak {
        \find(\modality{#allmodal}{c# loop_scope!(s#lhs, { break; s#slist }) #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c#  s#lhs = true; #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsContinue {
        \find(\modality{#allmodal}{c# loop_scope!(s#lhs, { continue; s#slist }) #c}\endmodality (post))
        \replacewith({lhs := FALSE}post)
        \heuristics(simplify_prog)
    };

    lsLblContinueMatch {
        \find(\modality{#allmodal}{c# s#lb: loop_scope!(s#lhs, { continue s#lb; s#slist }) #c}\endmodality (post))
        \replacewith({lhs := FALSE}post)
        \heuristics(simplify_prog)
    };

    lsLblContinueNoMatch1 {
        \schemaVar \program Expression lsExpr;

        \find(\modality{#allmodal}{c# loop_scope!(s#lhs, { continue s#lb; s#slist }) #c}\endmodality (post))
        \varcond(\storeExprIn(
                lsExpr,
                \modality{#allmodal}{
                      loop_scope!(s#lhs, { continue s#lb; s#slist }) }
                    \endmodality (post)))
        \varcond(\not \isLabeled(lsExpr))

        \replacewith(\modality{#allmodal}{c# s#lhs = true; continue s#lb; #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsLblContinueNoMatch2 {
        \schemaVar \program Expression lsExpr;

        \find(\modality{#allmodal}{c# s#lb1: loop_scope!(s#lhs, { continue s#lb; s#slist }) #c}\endmodality (post))
        \varcond(\different(lb1, lb))

        \replacewith(\modality{#allmodal}{c#  s#lhs = true; continue s#lb; #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    lsLblBreak {
        \find(\modality{#allmodal}{c# loop_scope!(s#lhs, { break s#lb; s#slist }) #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c#  { s#lhs = true; break s#lb; } #c}\endmodality (post))
        \heuristics(simplify_prog)
    };
}
