/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

/*
 * This file contains the known taclet options (aka choices) as well as their documentation.
 */

 \optionsDecl {
    /*! This option controls how integer numbers are modeled. */
    intRules: {
        /*! 'Arithmetic without overflow checking' treats integers as pure
         *   mathematical objects. The proof obligations are often easier to
         *   discharge. However, the model allows the verification of properties
         *   which do not hold on Rust's actual semantics. This is the default
         *   option.
         *   @choiceDefaultOption @choiceUnsound
         */
        ignoreOverFlow,
        /*! 'Rust semantics' treat integers the same way Rust would treat them.
         *  The different integer types operate within their respective value
         *  ranges. This is sound and complete. Proof obligations tend
         *  to get more complex with this setting.*/
        rustSemantics
    };

    /*! Rules dealing with Rust language constructs can be turned off by setting this to 'None'. */
    programRules: {Rust, /*! @choiceIncomplete */ None};

    /*! Which computer architecture to simulate for integers (usize/isize): 64-bit or 32-bit. */
    architecture: {
        A64, A32, A16
    };
    /*! Treatment of implicit panics */
    panics: {
        /*! If set to 'allow', implicit panics are raised.
            This is the default option.
         */
        allow,
        /*! If set to 'ignore', it is assumed that no implicit panic occurs.
            Warning: Reasoning with these rules is unsound.

         @choiceUnsound
         */
        ignore
    };
    /*!
    Loading less commonly used rules for (mathematical) integers,
    such as rules for bounded sums and products, modulo, or polynomials,
    can be disabled. If they are loaded, their application in the strategy
    can still be controlled as usual.

    This option is experimental. Depending of your understanding of 'less common',
    you may experience incompleteness. Doing proofs with Rust int semantics will not work, definitely.

    Not to be confused with intRules, which controls the semantics of the Rust int types.
    */
    integerSimplificationRules: {full, /*! @choiceIncomplete */ minimal}; // TODO: further refine this option
 }
