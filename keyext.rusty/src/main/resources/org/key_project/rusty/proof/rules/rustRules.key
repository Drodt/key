/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules for handling Rust programs

\schemaVariables {
    \modalOperator {diamond, box} #allmodal;

    \formula post, inv, post1;
    \program Type t, t2;
    //\program NonPrimitiveType npit;
    \program PrimitiveType pit;

    \term G q;
    \skolemTerm G sk;

    \program SimpleExpression se, se0, se1, se2;
    \program Variable loc;
    \program Variable_u32 loc_u32;

    \program Variable v, v0, v1, v2, boolv, a, a0, a1;

    \program NonSimpleExpression nse, nse0, nse1, nse2;
    \program Statement s, s0, s1;
    \program Expression e, e0, e1, e2;
    \program BlockExpression be, be0, be1;

    \program Pattern p;

    \program BoolExpression exBool;
    \program SimpleBoolExpression seBool, seBool0, seBool1;
    \program NonSimpleBoolExpression nseBool;

    \program [list] Statement slist, slist1, slist2, slist3;
    \program [list] Expression elist;
    \program [list] SimpleExpression selist;
}

// TODO: add taclet option for Rust programs
\rules {
    emptyModality {
        \find(\modality{#allmodal}{}\endmodality (post))
        \replacewith(post)
        //\heuristics(simplify_prog)
    };

    emptyModalityValue {
        \find(\modality{#allmodal}{s#se}\endmodality (post))
        \replacewith(post)
        //\heuristics(simplify_prog)
        \displayname "emptyModality"
    };

    returnUnfold {
        \find(\modality{#allmodal}{c# return s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# let s#v0: s#typeof(s#nse) = s#nse; return s#v0; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "returnUnfold"
    };

    // ---- block -----//
    emptyBlock {
        \find(\modality{#allmodal}{c# { s#e } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e; #c}\endmodality (post))
    };

    // -----------------------------------------------------------------------------------------
    //                        some common assignment rules
    // -----------------------------------------------------------------------------------------

    assignment {
        \find(\modality{#allmodal}{c# s#loc = s#se; #c}\endmodality (post))
        \replacewith({loc := se}\modality{#allmodal}{c#  #c}\endmodality (post))
        //\heuristics(simplify_prog, simplify_prog_subset)
    };

    // --------------- let-statements ----------------------------------------------//

    // TODO: Deal with types!
    letIdentPat {
        \find(\modality{#allmodal}{c# let s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatMut {
        \find(\modality{#allmodal}{c# let mut s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatAssign {
        \find(\modality{#allmodal}{c# let s#p : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let s#p : s#t; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    letIdentPatAssignMut {
        \find(\modality{#allmodal}{c# let mut s#p : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let mut s#p : s#t; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    // --------------- compound-assign-expressions ---------------------------------//

    compoundAssignPlus {
        \find(\modality{#allmodal}{c# s#e0 += s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 + s#e1; #c}\endmodality (post))
    };

    compoundAssignMinus {
        \find(\modality{#allmodal}{c# s#e0 -= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 - s#e1; #c}\endmodality (post))
    };

    compoundAssignMultiply {
        \find(\modality{#allmodal}{c# s#e0 *= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 * s#e1; #c}\endmodality (post))
    };

    compoundAssignDivide {
        \find(\modality{#allmodal}{c# s#e0 /= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 / s#e1; #c}\endmodality (post))
    };

    compoundAssignModulo {
        \find(\modality{#allmodal}{c# s#e0 %= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 % s#e1; #c}\endmodality (post))
    };

    compoundAssignAnd {
        \find(\modality{#allmodal}{c# s#e0 &= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 & s#e1; #c}\endmodality (post))
    };

    compoundAssignOr {
        \find(\modality{#allmodal}{c# s#e0 |= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 | s#e1; #c}\endmodality (post))
    };

    compoundAssignXor {
        \find(\modality{#allmodal}{c# s#e0 ^= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 ^ s#e1; #c}\endmodality (post))
    };

    compoundAssignShl {
        \find(\modality{#allmodal}{c# s#e0 <<= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 << s#e1; #c}\endmodality (post))
    };

    compoundAssignShr {
        \find(\modality{#allmodal}{c# s#e0 >>= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 >> s#e1; #c}\endmodality (post))
    };

    // --------------- if-expressions ----------------------------------------------//

    ifUnfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#nse; if s#boolv s#be0 #c}\endmodality (post))
        //\heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    ifElseUnfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#nse; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
        //\heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    if {
        \find(\modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be #c}\endmodality (post))
            \else(\modality{#allmodal}{c# #c}\endmodality (post)))
        \displayname "ifElse"
    };

    ifElse {
        \find(\modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be0 #c}\endmodality (post))
            \else(\modality{#allmodal}{c# s#be1 #c}\endmodality (post)))
        // \heuristics(split_if)
        \displayname "ifElse"
    };

    ifElseSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be  #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifTrue {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifElseTrue {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifFalse {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifElseFalse {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    // TODO: Are the other if rules really useful?

    // --------------------- match-expressions --------------------------------//

    condition {
        \find(\modality{#allmodal}{c# s#e = if s#e0 s#be0 else s#be1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# if s#e0 { s#e = s#be0; } else { s#e = s#be1; } #c}\endmodality (post))
        //\heuristics(simplify_prog, split_if)
    };

    conditionNotSimpleSimpleBranches {
        \find(\modality{#allmodal}{c# s#loc = if s#nse {s#se0} else {s#se1}; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#nse);
            s#v0 = s#nse;
            s#loc = if s#v0 {s#se0} else {s#se1}; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    conditionSimpleSimpleBranches {
        \find(\modality{#allmodal}{c# s#loc = if s#se {s#se0} else {s#se1}; #c}\endmodality (post))
        \replacewith({loc := \if(se = TRUE) \then(se0) \else(se1)}
            \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    conditionNotSimple {
        \find(\modality{#allmodal}{c# s#loc = if s#nse s#be0 else s#be1; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#nse);
            s#v0 = s#nse;
            s#loc = if s#v0 s#be0 else s#be1; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    // Add ProgramSVSort for patterns so that unfolding can be done independent of pattern
    //ifLetUnfold {
    //    \find(\modality{#allmodal}{c# if let s#pat = s#nse s#be #c}\endmodality (post))
    //    \varcond(\newTypeOf(v0, nse))
    //    \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; if let s#pat = s#v0 s#be  #c}\endmodality (post))
    //};

    //ifLetElseUnfold {
    //    \find(\modality{#allmodal}{c# if let s#pat = s#nse s#be0 else s#be1 #c}\endmodality (post))
    //    \varcond(\newTypeOf(v0, nse))
    //    \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; if let s#pat = s#v0 s#be0 else s#be1 #c}\endmodality (post))
    //};

    ifLetExclusive {
        \find(\modality{#allmodal}{c# if let s#se0..s#se1 = s#se2 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 < s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetInclusive {
        \find(\modality{#allmodal}{c# if let s#se0..=s#se1 = s#se2 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 <= s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetFrom {
        \find(\modality{#allmodal}{c# if let s#se0.. = s#se1 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetToInclusive {
        \find(\modality{#allmodal}{c# if let ..=s#se0 = s#se1 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se1 <= s#se0; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetExclusiveElse {
        \find(\modality{#allmodal}{c# if let s#se0..s#se1 = s#se2 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 < s#se1; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    ifLetInclusiveElse {
        \find(\modality{#allmodal}{c# if let s#se0..=s#se1 = s#se2 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 <= s#se1; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    ifLetFromElse {
        \find(\modality{#allmodal}{c# if let s#se0.. = s#se1 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se1; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    ifLetToInclusiveElse {
        \find(\modality{#allmodal}{c# if let ..=s#se0 = s#se1 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se1 <= s#se0; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };


    // --------------------- function calls -----------------------------------//

    // --------------------- method calls -------------------------------------//

    // --------------------- block assign -------------------------------------//

    assignBlockValue {
        \find(\modality{#allmodal}{c# s#e0 = {s#e1}; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e1; #c}\endmodality (post))
        \displayname "assignBlock"
    };

    assignBlock {
        \find(\modality{#allmodal}{c# s#e0 = {s#slist s#e1}; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# {s#slist s#e0 = s#e1; ()} #c}\endmodality (post))
    };

    // -------------------- tuple expressions ---------------------------------//

    tupleAssign {
        \find(\modality{#allmodal}{c# s#loc = (s#selist, s#nse, s#elist); #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; s#loc = (s#selist, s#v0, s#elist); #c}\endmodality (post))
    };

    // ------------------------------------------------------------------------
    // ----------- Rule for removing redundant parentheses
    // ------------------------------------------------------------------------

    removeParenthesesRight {
        \find(\modality{#allmodal}{c# s#e0 = (s#e1); #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e1; #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    removeParenthesesLeft {
        \find(\modality{#allmodal}{c# (s#e0) = s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e1; #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    // ------------------------------------------------------------------------
    // ----------- Rules for binary arithmetic operators applied to at least one compound expression
    // ------------------------------------------------------------------------

    compoundAddition1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse + s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v + s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "addition"
    };

    compoundAddition2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 + s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 + s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "addition"
    };

    compoundSubtraction1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse - s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v - s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "subtraction"
    };

    compoundSubtraction2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 - s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 - s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "subtraction"
    };

    compoundMultiplication1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse * s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v * s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    compoundMultiplication2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 * s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 * s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    compoundDivision1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse / s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v / s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "division"
    };

    compoundDivision2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 / s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 / s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    compoundModulo1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse % s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v % s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "modulo"
    };

    compoundModulo2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 % s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 % s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "modulo"
    };

    compoundBitwiseAnd1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse & s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v & s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseAnd"
    };

    compoundBitwiseAnd2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 & s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 & s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseAnd"
    };

    compoundBitwiseOr1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse | s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v | s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseOr"
    };

    compoundBitwiseOr2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 | s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 | s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    compoundBitwiseXor1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse ^ s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v ^ s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseXor"
    };

    compoundBitwiseXor2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 ^ s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 ^ s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseXor"
    };

    compoundShl1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse << s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v << s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shist left"
    };

    compoundShl2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 << s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 << s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shift left"
    };

    compoundShr1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse >> s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v >> s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shift right"
    };

    compoundShr2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 >> s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 >> s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shift right"
    };

    compoundEquality1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse == s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v == s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "equality"
    };

    compoundEquality2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 == s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 == s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "equality"
    };

    compoundInequality1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse != s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v != s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "inequality"
    };

    compoundInEquality2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 != s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 != s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "inequality"
    };

    compoundGreater1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse > s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v > s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater than"
    };

    compoundGreater2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 > s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 > s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater than"
    };

    compoundLess1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse < s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v < s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less than"
    };

    compoundLess2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 < s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 < s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less than"
    };

    compoundGreaterEqual1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse >= s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v >= s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater or equal"
    };

    compoundGreaterEqual2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 >= s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 >= s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater or equal"
    };

    compoundLessEqual1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse <= s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v <= s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less or equal"
    };

    compoundLessEqual2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 <= s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 <= s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less or equal"
    };

    equalityComparisonSimple {
        \find(\modality{#allmodal}{c# s#loc = s#se0 == s#se1; #c}\endmodality (post))
        \replacewith({loc := \if(se0 = se1) \then(TRUE) \else(FALSE)}
        \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "equality comparison"
    };

    less_equal_than_comparison {
        \find(\modality{#allmodal}{c# s#loc = s#se0 <= s#se1; #c}\endmodality (post))
        \replacewith(\if(leq(se0, se1)) \then(\modality{#allmodal}{c# s#loc = true; #c}\endmodality (post))
            \else(\modality{#allmodal}{c# s#loc = false; #c}\endmodality (post)))
        //\heuristics(obsolete, simplify_prog, split_if)
        \displayname "less-or-equal than distinction"
    };

    // ------------------------------------------------------------------------
    // ---------------------- Rules boolean expressions -----------------------
    // ------------------------------------------------------------------------

    compoundNotBoolSimple {
        \find(\modality{#allmodal}{c# s#loc=!s#seBool; #c}\endmodality (post))
        \replacewith({loc := \if(seBool = TRUE) \then(FALSE) \else(TRUE)}\modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_expression)
        \displayname "negation"
    };

    compoundNotBoolNonSimple {
        \find(\modality{#allmodal}{c# s#loc=!s#nseBool; #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# let s#v : bool = s#nseBool; s#loc = !s#v; #c}\endmodality (post))
        //\heuristics(simplify_expression)
        \displayname "negation"
    };

    compoundAndNonSimple {
        \find(\modality{#allmodal}{c# s#loc=s#exBool && s#nseBool; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#loc = if !s#exBool { false } else { s#nseBool }; #c}\endmodality (post))
        //\heuristics(simplify_expression)
        \displayname "and"
    };

    compoundAndMixed {
        \find(\modality{#allmodal}{c# s#loc=s#nseBool && s#seBool; #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# let s#v : bool = s#nseBool; s#loc = s#v && s#seBool; #c}\endmodality (post))
        //\heuristics(simplify_expression)
        \displayname "and"
    };

    compoundAndSimple {
        \find(\modality{#allmodal}{c# s#loc=s#seBool0 && s#seBool1; #c}\endmodality (post))
        \replacewith({loc := \if(seBool0 = TRUE) \then(\if(seBool1 = TRUE) \then(TRUE) \else (FALSE)) \else (FALSE)}
            \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_expression)
        \displayname "and"
    };

    // ------------------------------------------------------------------------
    // ---------------------- Rules for references ----------------------------
    // ------------------------------------------------------------------------

    borrowShared {
        \find(\modality{#allmodal}{c# s#loc = &s#a; #c}\endmodality (post))
        \replacewith({loc := createSRef(a)}
            \modality{#allmodal}{c# #c}\endmodality (post))
        \displayname "borrowShared"
    };

    borrowMut {
        \find(\modality{#allmodal}{c# s#loc = &mut s#a; #c}\endmodality (post))
        \replacewith({loc := pvToMutRef(a)}
            \modality{#allmodal}{c# #c}\endmodality (post))
    };

    mutate {
        \find(\modality{#allmodal}{c# *s#a = s#se; #c}\endmodality (post))
        \replacewith({a *-> se}
            \modality{#allmodal}{c# #c}\endmodality (post))
    };
}
