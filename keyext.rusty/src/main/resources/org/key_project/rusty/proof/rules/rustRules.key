/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules for handling Rust programs

\schemaVariables {
    \modalOperator {diamond, box} #allmodal;

    \formula post, inv, post1;
    \program Type t, t2;
    //\program NonPrimitiveType npit;
    \program PrimitiveType pit;

    \term G q;
    \skolemTerm G sk;

    \program SimpleExpression se, se0, se1, se2;
    \program Variable loc;

    \program Variable v, v0, v1, v2, boolv, a, a0, a1;

    \program NonSimpleExpression nse, nse0, nse1, nse2;
    \program Statement s, s0, s1;
    \program Expression e, e0, e1, e2;
    \program BlockExpression be, be0, be1;

    \program [list] Statement slist, slist1, slist2, slist3;
}

// TODO: add taclet option for Rust programs
\rules {
    emptyModality {
        \find(\modality{#allmodal}{s#se}\endmodality (post))
        \replacewith(post)
        //\heuristics(simplify_prog)
    };

    /* TODO: uncomment when functions are in: returnUnfold {
        \find(\modality{#allmodal}{c# return #nse; #c}\endmodality (post))
        \varcond(\newTypeOf(#v0, #nse))
        \replacewith(\modality{#allmodal}{c# let s#v0 = s#nse; return s#v0; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "returnUnfold"
    };*/

    // ---- block -----//
    emptyBlock {
        \find(\modality{#allmodal}{c# { s#e } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e; #c}\endmodality (post))
    };

    // -----------------------------------------------------------------------------------------
    //                        some common assignment rules
    // -----------------------------------------------------------------------------------------

    assignment {
        \find(\modality{#allmodal}{c# s#loc = s#se; #c}\endmodality (post))
        \replacewith({loc := se}\modality{#allmodal}{c#  #c}\endmodality (post))
        //\heuristics(simplify_prog, simplify_prog_subset)
    };

    // --------------- if-expressions ----------------------------------------------//

    if {
        \find(\modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be #c}\endmodality (post))
            \else(\modality{#allmodal}{c# #c}\endmodality (post)))
        \displayname "ifElse"
    };

    ifElse {
        \find(\modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be0 #c}\endmodality (post))
            \else(\modality{#allmodal}{c# s#be1 #c}\endmodality (post)))
        // \heuristics(split_if)
        \displayname "ifElse"
    };

    ifElseSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be  #c}\endmodality (post))
        "if #se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post)) \add(se = TRUE ==>);
        "if #se false":
            \replacewith( ==> \modality{#allmodal}{c# #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };
}
