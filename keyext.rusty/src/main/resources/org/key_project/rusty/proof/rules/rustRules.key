/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules for handling Rust programs

\sorts {
    \generic El;
    \generic S;
}

\schemaVariables {
    \modalOperator {diamond, box} #allmodal;

    \formula post, inv, post1;
    \program Type t, t2;
    //\program NonPrimitiveType npit;
    \program PrimitiveType pit;

    \term G q;
    \skolemTerm G sk;

    \program SimpleExpression se, se0, se1, se2;
    \program Variable loc;
    \program Variable_u32 loc_u32;

    \program Variable v, v0, v1, v2, boolv, a, a0, a1;

    \program NonSimpleExpression nse, nse0, nse1, nse2;
    \program Statement s, s0, s1;
    \program Expression e, e0, e1, e2;
    \program BlockExpression be, be0, be1;

    \program Pattern p;

    \program BoolExpression exBool;
    \program SimpleBoolExpression seBool, seBool0, seBool1;
    \program NonSimpleBoolExpression nseBool;

    \program [list] Statement slist, slist1, slist2, slist3;
    \program [list] Expression elist;
    \program [list] SimpleExpression selist;

    \program NonModelFunctionBody fb;
}

\rules(programRules:Rust) {
    emptyModality {
        \find(\modality{#allmodal}{}\endmodality (post))
        \replacewith(post)
        //\heuristics(simplify_prog)
    };

    emptyModalityUnfold {
        \find(\modality{#allmodal}{s#nse}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{let s#v0: s#typeof(s#nse) = s#nse; s#v0}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "emptyModality"
    };

    emptyModalityValue {
        \find(\modality{#allmodal}{s#se}\endmodality (post))
        \replacewith(post)
        //\heuristics(simplify_prog)
        \displayname "emptyModality"
    };

    // ---- block ---- //
    emptyBlockValue {
        \find(\modality{#allmodal}{c# { s#e } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e #c}\endmodality (post))
    };

    emptyBlock {
        \find(\modality{#allmodal}{c# { } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# () #c}\endmodality (post))
    };

    assignBlockValue {
        \find(\modality{#allmodal}{c# s#e0 = {s#e1} #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e1 #c}\endmodality (post))
        \displayname "assignBlock"
    };

    assignBlock {
        \find(\modality{#allmodal}{c# s#e0 = {s#slist; s#e1} #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# {s#slist; s#e0 = s#e1} #c}\endmodality (post))
    };

    // ---- const block ---- //
    constBlock {
        \find(\modality{#allmodal}{c# { const s#be } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#be #c}\endmodality (post))
    };

    // ---- if ---- //

    ifUnfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# { let s#boolv : bool = s#nse; if s#boolv s#be0 } #c}\endmodality (post))
        //\heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    ifElseUnfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# { let s#boolv : bool = s#nse; if s#boolv s#be0 else s#be1 } #c}\endmodality (post))
        //\heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    if {
        \find(\modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be #c}\endmodality (post))
            \else(\modality{#allmodal}{c# () #c}\endmodality (post)))
        \displayname "ifElse"
    };

    ifElse {
        \find(\modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be0 #c}\endmodality (post))
            \else(\modality{#allmodal}{c# s#be1 #c}\endmodality (post)))
        // \heuristics(split_if)
        \displayname "ifElse"
    };

    ifElseSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be  #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# () #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifTrue {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifElseTrue {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifFalse {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifElseFalse {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    // TODO: Are these last if rules really useful?

    condition {
        \find(\modality{#allmodal}{c# s#e = if s#e0 s#be0 else s#be1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# if s#e0 { s#e = s#be0 } else { s#e = s#be1 } #c}\endmodality (post))
        //\heuristics(simplify_prog, split_if)
    };

    conditionNotSimpleSimpleBranches {
        \find(\modality{#allmodal}{c# s#loc = if s#nse {s#se0} else {s#se1}; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#nse);
            s#v0 = s#nse;
            s#loc = if s#v0 {s#se0} else {s#se1}; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    conditionSimpleSimpleBranches {
        \find(\modality{#allmodal}{c# s#loc = if s#se {s#se0} else {s#se1}; #c}\endmodality (post))
        \replacewith({loc := \if(se = TRUE) \then(se0) \else(se1)}
            \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    conditionNotSimple {
        \find(\modality{#allmodal}{c# s#loc = if s#nse s#be0 else s#be1; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#nse);
            s#v0 = s#nse;
            s#loc = if s#v0 s#be0 else s#be1; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    // ---- if let ---- //

    // Add ProgramSVSort for patterns so that unfolding can be done independent of pattern
    //ifLetUnfold {
    //    \find(\modality{#allmodal}{c# if let s#pat = s#nse s#be #c}\endmodality (post))
    //    \varcond(\newTypeOf(v0, nse))
    //    \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; if let s#pat = s#v0 s#be  #c}\endmodality (post))
    //};

    //ifLetElseUnfold {
    //    \find(\modality{#allmodal}{c# if let s#pat = s#nse s#be0 else s#be1 #c}\endmodality (post))
    //    \varcond(\newTypeOf(v0, nse))
    //    \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; if let s#pat = s#v0 s#be0 else s#be1 #c}\endmodality (post))
    //};

    ifLetExclusive {
        \find(\modality{#allmodal}{c# if let s#se0..s#se1 = s#se2 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 < s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetInclusive {
        \find(\modality{#allmodal}{c# if let s#se0..=s#se1 = s#se2 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 <= s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetFrom {
        \find(\modality{#allmodal}{c# if let s#se0.. = s#se1 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetToInclusive {
        \find(\modality{#allmodal}{c# if let ..=s#se0 = s#se1 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se1 <= s#se0; if s#boolv s#be #c}\endmodality (post))
    };

    ifLetExclusiveElse {
        \find(\modality{#allmodal}{c# if let s#se0..s#se1 = s#se2 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# { let s#boolv : bool = s#se0 <= s#se2 && s#se2 < s#se1; if s#boolv s#be0 else s#be1 } #c}\endmodality (post))
    };

    ifLetInclusiveElse {
        \find(\modality{#allmodal}{c# if let s#se0..=s#se1 = s#se2 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 <= s#se1; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    ifLetFromElse {
        \find(\modality{#allmodal}{c# if let s#se0.. = s#se1 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se1; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    ifLetToInclusiveElse {
        \find(\modality{#allmodal}{c# if let ..=s#se0 = s#se1 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se1 <= s#se0; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    // ---- Loop ---- //
    // See loopScopeRules.key

    // ---- match expr ---- //
    // TODO @ Nihal

    // ---- Unsafe block ---- //
    // TODO: How?

    // ---- Labeled Block ---- //
    // TODO

    // ---- Array Expression ---- //
    // ------ Enumerate ------ //
    // TODO

    // ------ Repeat ------ //
    unfold_repeat_elem {
            \find(\modality{#allmodal}{c# s#loc = [s#nse; s#se] #c}\endmodality (post))
            \varcond(\newTypeOf(v, nse))
            \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = [s#v; s#se] } #c}\endmodality (post))
        };

    array_repeat {
        \find(\modality{#allmodal}{c# s#loc = [s#se0; s#se1] #c}\endmodality (post))
        \varcond(\hasSort(se0, \sort(El)), \sub(\typeof(se1), \sort(int)))
        \replacewith({loc := arr_repeat<[El, const se1]>(se0)}\modality{#allmodal}{c# () #c}\endmodality (post))
    };

    // ---- Break ---- //
    // See loop rules / labeled block rules

    // ---- Call ---- //
    // TODO

    // ---- Closure ---- //
    // TODO

    // ---- Continue ---- //
    // See loop rules

    // ---- Field expr ---- //
    // TODO

    // ---- Index expr ---- //

    unfold_lhs_index_indexed {
        \find(\modality{#allmodal}{c# s#nse[s#e] = s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#v[s#e] = s#se } #c}\endmodality (post))
    };

    unfold_lhs_index_index {
        \find(\modality{#allmodal}{c# s#se0[s#nse] = s#se1 #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#se0[s#v] = s#se1 } #c}\endmodality (post))
    };

    // TODO: rework once we use index traits
    array_index_set {
        \schemaVar \term int N;
        \schemaVar \program RustUsizeExpression idx;
        \find(\modality{#allmodal}{c# s#loc[s#idx] = s#se #c}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(se, \sort(El)), \hasSort(loc, \sort(Array<[El, const N]>)))
        "Normal execution":
            \replacewith({loc := arr_set<[El, const N]>(loc, idx, se)}\modality{#allmodal}{c# () #c}\endmodality (post))
            \add(N > idx ==>);
        "s#idx out of bounds":
            \replacewith(\modality{#allmodal}{c# panic!() #c}\endmodality (post))
            \add(!(N > idx) ==>)
    };

    unfold_rhs_index_indexed {
        \find(\modality{#allmodal}{c# s#e0 = s#nse[s#e1] #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#e0 = s#v[s#e1] } #c}\endmodality (post))
    };

    unfold_rhs_index_index {
        \find(\modality{#allmodal}{c# s#e = s#se[s#nse] #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#e = s#se[s#v] } #c}\endmodality (post))
    };

    // TODO: rework once we use index traits
    array_index_get {
        \schemaVar \term int N;
        \schemaVar \program RustUsizeExpression idx;
        \find(\modality{#allmodal}{c# s#loc = s#se[s#idx] #c}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(loc, \sort(El)), \hasSort(se, \sort(Array<[El, const N]>)))
        "Normal execution":
            \replacewith({loc := arr_get<[El, const N]>(se, idx)}\modality{#allmodal}{c# () #c}\endmodality (post))
            \add(N > idx ==>);
        "s#idx out of bounds":
            \replacewith(\modality{#allmodal}{c# panic!() #c}\endmodality (post))
            \add(!(N > idx) ==>)
    };

    // ---- Literal expr ---- //
    // Nothing to do

    // ---- Method call ---- //
    // TODO

    // ---- Operator expr ---- //

    // ------ Arithmetic ------ //

    // -------- Addition -------- //

    // TODO: Generalize this for s#nse = s#e
    addition_complex_lhs {
        \find(\modality{#allmodal}{c# s#nse=s#e0 + s#e1 #c}\endmodality (post))
        \varcond(\newTypeOf(v, e0))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#e0) = s#e0 + s#e1; s#nse=s#v } #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "addition"
    };

    compoundAddition1 {
        \find(\modality{#allmodal}{c# s#se0=s#nse + s#se1; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#se0=s#v + s#se1; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "addition"
    };

    compoundAddition2 {
        \find(\modality{#allmodal}{c# s#se=s#e + s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e = s#v0 + s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "addition"
    };

    // -------- Division -------- //

    compoundDivision1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse / s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v / s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "division"
    };

    compoundDivision2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 / s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 / s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    // -------- Multiplication -------- //

    compoundMultiplication1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse * s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v * s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    compoundMultiplication2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 * s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 * s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    // -------- Remainder -------- //

    compoundModulo1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse % s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v % s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "modulo"
    };

    compoundModulo2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 % s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 % s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "modulo"
    };

    // -------- Subtraction -------- //

    compoundSubtraction1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse - s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v - s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "subtraction"
    };

    compoundSubtraction2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 - s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 - s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "subtraction"
    };

    // ------ Assignment ------ //

    assignment {
        \find(\modality{#allmodal}{c# s#loc = s#se #c}\endmodality (post))
        \replacewith({loc := se}\modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    // ------ Bitwise ------ //

    // -------- And -------- //
    compoundBitwiseAnd1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse & s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v & s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseAnd"
    };

    compoundBitwiseAnd2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 & s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 & s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseAnd"
    };

    // -------- Or -------- //
    compoundBitwiseOr1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse | s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v | s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseOr"
    };

    compoundBitwiseOr2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 | s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 | s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "multiplication"
    };

    // -------- Xor -------- //
    compoundBitwiseXor1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse ^ s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v ^ s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseXor"
    };

    compoundBitwiseXor2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 ^ s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 ^ s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "bitwiseXor"
    };

    // -------- Shl -------- //
    compoundShl1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse << s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v << s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shist left"
    };

    compoundShl2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 << s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 << s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shift left"
    };

    // -------- Shr -------- //
    compoundShr1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse >> s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v >> s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shift right"
    };

    compoundShr2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 >> s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 >> s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "shift right"
    };

    // ------ Borrow ------ //

    borrowSharedUnfold {
        \find(\modality{#allmodal}{c# s#e = &s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#e = &s#v } #c}\endmodality (post))
        \displayname "borrowShared"
    };

    borrowShared {
        \find(\modality{#allmodal}{c# s#loc = &s#a #c}\endmodality (post))
        \varcond(\hasSort(a, \sort(S)))
        \replacewith({loc := refS<[S]>(a)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \displayname "borrowShared"
    };

    borrowMutUnfold {
        \find(\modality{#allmodal}{c# s#e = &mut s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#e = &mut s#v } #c}\endmodality (post))
        \displayname "borrowMut"
    };

    borrowMut {
        \find(\modality{#allmodal}{c# s#loc = &mut s#a #c}\endmodality (post))
        \varcond(\hasSort(a, \sort(S)))
        \replacewith({loc := refM<[S]>(pvToPlace(a))}
            \modality{#allmodal}{c# () #c}\endmodality (post))
    };

    // ------ Comparison ------ //

    // -------- Equality -------- //
    compoundEquality1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse == s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v == s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "equality"
    };

    compoundEquality2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 == s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 == s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "equality"
    };

    equalityComparisonSimple {
        \find(\modality{#allmodal}{c# s#loc = s#se0 == s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(se0 = se1) \then(TRUE) \else(FALSE)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality comparison"
    };

    // -------- Greater than -------- //
    compoundGreater1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse > s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v > s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater than"
    };

    compoundGreater2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 > s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 > s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater than"
    };

    // -------- Greater or equal -------- //
    compoundGreaterEqual1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse >= s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v >= s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater or equal"
    };

    compoundGreaterEqual2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 >= s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 >= s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "greater or equal"
    };

    // -------- Less than -------- //
    compoundLess1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse < s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v < s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less than"
    };

    compoundLess2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 < s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 < s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less than"
    };

    // -------- Less than or equal -------- //
    compoundLessEqual1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse <= s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v <= s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less or equal"
    };

    compoundLessEqual2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 <= s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 <= s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "less or equal"
    };

    less_equal_than_comparison {
        \find(\modality{#allmodal}{c# s#loc = s#se0 <= s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(leq(se0, se1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less-or-equal than distinction"
    };

    // -------- Inequality -------- //
    compoundInequality1 {
        \find(\modality{#allmodal}{c# s#e0=s#nse != s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v != s#se; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "inequality"
    };

    compoundInequality2 {
        \find(\modality{#allmodal}{c# s#e0=s#e1 != s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 != s#v1;
        #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "inequality"
    };

    inequalityComparisonSimple {
        \find(\modality{#allmodal}{c# s#loc = s#se0 != s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(se0 = se1) \then(FALSE) \else(TRUE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality comparison"
    };

    // ------ Compound assignment ------ //
    // TODO: rework w/ trait call

    compoundAssignPlus {
        \find(\modality{#allmodal}{c# s#e0 += s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 + s#e1 #c}\endmodality (post))
    };

    compoundAssignAnd {
        \find(\modality{#allmodal}{c# s#e0 &= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 & s#e1; #c}\endmodality (post))
    };

    compoundAssignOr {
        \find(\modality{#allmodal}{c# s#e0 |= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 | s#e1; #c}\endmodality (post))
    };

    compoundAssignXor {
        \find(\modality{#allmodal}{c# s#e0 ^= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 ^ s#e1; #c}\endmodality (post))
    };

    compoundAssignDivide {
        \find(\modality{#allmodal}{c# s#e0 /= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 / s#e1; #c}\endmodality (post))
    };

    compoundAssignMultiply {
        \find(\modality{#allmodal}{c# s#e0 *= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 * s#e1; #c}\endmodality (post))
    };

    compoundAssignModulo {
        \find(\modality{#allmodal}{c# s#e0 %= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 % s#e1; #c}\endmodality (post))
    };

    compoundAssignShl {
        \find(\modality{#allmodal}{c# s#e0 <<= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 << s#e1; #c}\endmodality (post))
    };

    compoundAssignShr {
        \find(\modality{#allmodal}{c# s#e0 >>= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 >> s#e1; #c}\endmodality (post))
    };

    compoundAssignMinus {
        \find(\modality{#allmodal}{c# s#e0 -= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 - s#e1; #c}\endmodality (post))
    };

    // ------ Deref ------ //

    deref_unfold_right {
        \find(\modality{#allmodal}{c# *s#e = s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; *s#e = s#v } #c}\endmodality (post))
    };

    deref_unfold_left {
        \find(\modality{#allmodal}{c# *s#nse = s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; *s#v = s#se } #c}\endmodality (post))
    };

    mutate {
        \find(\modality{#allmodal}{c# *s#a = s#se #c}\endmodality (post))
        \replacewith({a *-> se}
            \modality{#allmodal}{c# () #c}\endmodality (post))
    };

    // ------ Lazy boolean ------ //

    // -------- And -------- //
    compoundAndNonSimple {
        \find(\modality{#allmodal}{c# s#loc=s#exBool && s#nseBool #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#loc = if !s#exBool { false } else { s#nseBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "and"
    };

    compoundAndMixed {
        \find(\modality{#allmodal}{c# s#loc=s#nseBool && s#seBool #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# { let s#v : bool = s#nseBool; s#loc = s#v && s#seBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "and"
    };

    compoundAndSimple {
        \find(\modality{#allmodal}{c# s#loc=s#seBool0 && s#seBool1 #c}\endmodality (post))
        \replacewith({loc := \if(seBool0 = TRUE & seBool1 = TRUE) \then(TRUE) \else (FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "and"
    };

    // -------- Or -------- //
    compoundOrNonSimple {
        \find(\modality{#allmodal}{c# s#loc=s#exBool || s#nseBool #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#loc = if s#exBool { true } else { s#nseBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "or"
    };

    compoundOrMixed {
        \find(\modality{#allmodal}{c# s#loc=s#nseBool || s#seBool #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# { let s#v : bool = s#nseBool; s#loc = s#v || s#seBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "or"
    };

    compoundOrSimple {
        \find(\modality{#allmodal}{c# s#loc=s#seBool0 || s#seBool1 #c}\endmodality (post))
        \replacewith({loc := \if(seBool0 = TRUE | seBool1 = TRUE) \then(TRUE) \else (FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "or"
    };

    // ------ Negation ------ //

    // -------- Bitwise -------- //
    compoundNotBoolSimple {
        \find(\modality{#allmodal}{c# s#loc=!s#seBool #c}\endmodality (post))
        \replacewith({loc := \if(seBool = TRUE) \then(FALSE) \else(TRUE)}\modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "negation"
    };

    compoundNotBoolNonSimple {
        \find(\modality{#allmodal}{c# s#loc=!s#nseBool; #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# { let s#v : bool = s#nseBool; s#loc = !s#v } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "negation"
    };

    // -------- Sign -------- //
    // TODO

    // ------ Raw borrow ------ //
    // TODO

    // ------ Cast ------ //
    // TODO

    // ---- Path expr ---- //
    // Nothing to do
    // TODO: Unit structs, enums?

    // ---- Return ---- //

    returnUnfold {
        \find(\modality{#allmodal}{c# return s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# let s#v0: s#typeof(s#nse) = s#nse; return s#v0; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "returnUnfold"
    };

    functionBodyExpand {
        \find(\modality{#allmodal}{c# s#fb; #c}\endmodality (post))
        \replacewith(introAtPreDefs(\modality{#allmodal}{c# s#expand_fn_body(s#fb); #c}\endmodality (post)))
        \heuristics(simplify_prog)
    };

    emptyFrame {
        \find(\modality{#allmodal}{c# fn_frame!(s#v0, {}) #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#v0 = () #c}\endmodality (post))
    };

    implicitReturn {
        \find(\modality{#allmodal}{c# fn_frame!(s#v0, {s#se}) #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#v0 = s#se #c}\endmodality (post))
    };

    unfoldImplicitReturn {
        \find(\modality{#allmodal}{c# fn_frame!(s#v0, {s#nse}) #c}\endmodality (post))
        \varcond(\newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# fn_frame!(s#v0, { let s#v1 = s#nse; s#v1 }) #c}\endmodality (post))
    };

    // ---- Struct expr ---- //
    // TODO

    // ---- Tuple expr ---- //

    tupleAssign {
        \find(\modality{#allmodal}{c# s#loc = (s#selist, s#nse, s#elist); #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; s#loc = (s#selist, s#v0, s#elist); #c}\endmodality (post))
    };

    // Statements

    simpleExprStmt {
        \find(\modality{#allmodal}{c# s#se; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
    };

    // ---- let stmt ---- //

    letIdentPat {
        \find(\modality{#allmodal}{c# let s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatNoType {
        \find(\modality{#allmodal}{c# let s#v0; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatMut {
        \find(\modality{#allmodal}{c# let mut s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatMutNoType {
        \find(\modality{#allmodal}{c# let mut s#v0; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatAssign {
        \find(\modality{#allmodal}{c# let s#p : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let s#p : s#t; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    letIdentPatAssignNoType {
        \find(\modality{#allmodal}{c# let s#p = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let s#p; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    letIdentPatAssignMut {
        \find(\modality{#allmodal}{c# let mut s#p : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let mut s#p : s#t; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    letIdentPatAssignMutNoType {
        \find(\modality{#allmodal}{c# let mut s#p = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let mut s#p; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };
}
