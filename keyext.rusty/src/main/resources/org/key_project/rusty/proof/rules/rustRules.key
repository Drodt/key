/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules for handling Rust programs

\schemaVariables {
    \modalOperator {diamond, box} #allmodal;

    \formula post, inv, post1;
    \program Type t, t2;
    //\program NonPrimitiveType npit;
    \program PrimitiveType pit;

    \term G q;
    \skolemTerm G sk;

    \program SimpleExpression se, se0, se1, se2;
    \program Variable loc;

    \program Variable v, v0, v1, v2, boolv, a, a0, a1;

    \program NonSimpleExpression nse, nse0, nse1, nse2;
    \program Statement s, s0, s1;
    \program Expression e, e0, e1, e2;
    \program BlockExpression be, be0, be1;

    \program [list] Statement slist, slist1, slist2, slist3;
    \program [list] Expression elist;
    \program [list] SimpleExpression selist;
}

// TODO: add taclet option for Rust programs
\rules {
    emptyModality {
        \find(\modality{#allmodal}{s#se}\endmodality (post))
        \replacewith(post)
        //\heuristics(simplify_prog)
    };

    returnUnfold {
        \find(\modality{#allmodal}{c# return s#nse; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# let s#v0: s#typeof(s#nse) = s#nse; return s#v0; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "returnUnfold"
    };

    // ---- block -----//
    emptyBlock {
        \find(\modality{#allmodal}{c# { s#e } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e; #c}\endmodality (post))
    };

    // -----------------------------------------------------------------------------------------
    //                        some common assignment rules
    // -----------------------------------------------------------------------------------------

    assignment {
        \find(\modality{#allmodal}{c# s#loc = s#se; #c}\endmodality (post))
        \replacewith({loc := se}\modality{#allmodal}{c#  #c}\endmodality (post))
        //\heuristics(simplify_prog, simplify_prog_subset)
    };

    // --------------- let-statements ----------------------------------------------//

    // TODO: Deal with types!
    /*letIdentPat {
        \find(\modality{#allmodal}{c# let s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatMut {
        \find(\modality{#allmodal}{c# let mut s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatAssign {
        \find(\modality{#allmodal}{c# let s#v0 : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let s#v0 : s#t; s#v0 = s#e; #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    letIdentPatAssignMut {
        \find(\modality{#allmodal}{c# let mut s#v0 : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let mut s#v0 : s#t; s#v0 = s#e; #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };*/

    // --------------- compound-assign-expressions ---------------------------------//

    compoundAssignPlus {
        \find(\modality{#allmodal}{c# s#e0 += s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 + s#e1; #c}\endmodality (post))
    };

    compoundAssignMinus {
        \find(\modality{#allmodal}{c# s#e0 -= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 - s#e1; #c}\endmodality (post))
    };

    compoundAssignMultiply {
        \find(\modality{#allmodal}{c# s#e0 *= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 * s#e1; #c}\endmodality (post))
    };

    compoundAssignDivide {
        \find(\modality{#allmodal}{c# s#e0 /= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 / s#e1; #c}\endmodality (post))
    };

    compoundAssignModulo {
        \find(\modality{#allmodal}{c# s#e0 %= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 % s#e1; #c}\endmodality (post))
    };

    compoundAssignAnd {
        \find(\modality{#allmodal}{c# s#e0 &= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 & s#e1; #c}\endmodality (post))
    };

    compoundAssignOr {
        \find(\modality{#allmodal}{c# s#e0 |= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 | s#e1; #c}\endmodality (post))
    };

    compoundAssignXor {
        \find(\modality{#allmodal}{c# s#e0 ^= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 ^ s#e1; #c}\endmodality (post))
    };

    compoundAssignShl {
        \find(\modality{#allmodal}{c# s#e0 <<= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 << s#e1; #c}\endmodality (post))
    };

    compoundAssignShr {
        \find(\modality{#allmodal}{c# s#e0 >>= s#e1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 >> s#e1; #c}\endmodality (post))
    };

    // --------------- if-expressions ----------------------------------------------//

    ifUnfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#nse; if s#boolv s#be0 #c}\endmodality (post))
        //\heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    ifElseUnfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#nse; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
        //\heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    if {
        \find(\modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be #c}\endmodality (post))
            \else(\modality{#allmodal}{c# #c}\endmodality (post)))
        \displayname "ifElse"
    };

    ifElse {
        \find(\modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be0 #c}\endmodality (post))
            \else(\modality{#allmodal}{c# s#be1 #c}\endmodality (post)))
        // \heuristics(split_if)
        \displayname "ifElse"
    };

    ifElseSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifSplit {
        \find( ==> \modality{#allmodal}{c# if s#se s#be  #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# #c}\endmodality (post)) \add(se = FALSE ==>)
        //\heuristics(split_if)
        \displayname "ifElseSplit"
    };

    ifTrue {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifElseTrue {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifFalse {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    ifElseFalse {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post))
        //\heuristics(simplify_prog)
    };

    // TODO: Are the other if rules really useful?

    // --------------------- match-expressions --------------------------------//

    condition {
        \find(\modality{#allmodal}{c# s#e = if s#e0 s#be0 else s#be1; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# if s#e0 { s#e = s#be0; ()} else { s#e = s#be1; ()} #c}\endmodality (post))
        //\heuristics(simplify_prog, split_if)
    };

    conditionNotSimple {
        \find(\modality{#allmodal}{c# s#loc = if s#nse {s#se0} else {s#se1}; #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c#
            let s#v0 : s#typeof(s#nse);
            s#v0 = s#nse;
            s#loc = if s#v0 {s#se0} else {s#se1}; #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    conditionSimple {
        \find(\modality{#allmodal}{c# s#loc = if s#se {s#se0} else {s#se1}; #c}\endmodality (post))
        \replacewith({loc := \if(se = TRUE) \then(se0) \else(se1)}
            \modality{#allmodal}{c# #c}\endmodality (post))
        //\heuristics(simplify_prog)
        \displayname "condition"
    };

    // --------------------- function calls -----------------------------------//

    // --------------------- method calls -------------------------------------//

    // --------------------- block assign -------------------------------------//

    assignBlockSimple {
        \find(\modality{#allmodal}{c# s#e = {s#se}; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e = s#se; #c}\endmodality (post))
        \displayname "assignBlock"
    };

    assignBlock {
        \find(\modality{#allmodal}{c# s#e0 = {s#slist s#e1}; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# {s#slist s#e0 = s#e1; ()} #c}\endmodality (post))
    };

    // -------------------- tuple expressions ---------------------------------//

    tupleAssign {
        \find(\modality{#allmodal}{c# s#loc = (s#selist, s#nse, s#elist); #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; s#loc = (s#selist, s#v0, s#elist); #c}\endmodality (post))
    };
}
