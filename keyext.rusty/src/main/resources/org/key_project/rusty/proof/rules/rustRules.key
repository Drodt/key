/* This file is part of KeY - https://key-project.org
 * KeY is licensed under the GNU General Public License Version 2
 * SPDX-License-Identifier: GPL-2.0-only */

// This file contains rules for handling Rust programs

/* General naming scheme
 * - Use snake_case
 * - Assignment where expr is on lhs: expr_assign
 * - Assignment where expr is on rhs: assign_expr
 *   - If unfolding is necessary: assign_expr_unfold_*
 */

\sorts {
    \generic El;
    \generic S;
}

\schemaVariables {
    \modalOperator {diamond, box} #allmodal;

    \formula post, inv, post1;
    \program Type t, t2;
    //\program NonPrimitiveType npit;
    \program PrimitiveType pit;

    \term G q;
    \skolemTerm G sk;

    \program SimpleExpression se, se0, se1, se2;
    \program Variable loc, loc0, loc1;

    \program Variable v, v0, v1, v2, boolv, a, a0, a1;

    \program NonSimpleExpression nse, nse0, nse1, nse2;
    \program Statement s, s0, s1;
    \program Expression e, e0, e1, e2;
    \program BlockExpression be, be0, be1;

    \program Label lbl, lbl0, lbl1;

    \program Pattern p;

    \program BoolExpression exBool;
    \program SimpleBoolExpression seBool, seBool0, seBool1;
    \program NonSimpleBoolExpression nseBool;

    \program [list] Statement slist, slist1, slist2, slist3;
    \program [list] Expression elist;
    \program [list] SimpleExpression selist;

    \program NonModelFunctionBody fb;
}

\rules(programRules:Rust) {
    empty_modality {
        \find(\modality{#allmodal}{}\endmodality (post))
        \replacewith(post)
        \heuristics(simplify_prog)
    };

    empty_modality_unfold {
        \find(\modality{#allmodal}{s#nse}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{let s#v0: s#typeof(s#nse) = s#nse; s#v0}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "emptyModality"
    };

    empty_modality_value {
        \find(\modality{#allmodal}{s#se}\endmodality (post))
        \replacewith(post)
        \heuristics(simplify_prog)
        \displayname "emptyModality"
    };

    // ---- block ---- //
    empty_block_value {
        \find(\modality{#allmodal}{c# { s#e } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    empty_block {
        \find(\modality{#allmodal}{c# { } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    assign_block_value {
        \find(\modality{#allmodal}{c# s#loc = {s#e} #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#loc = s#e #c}\endmodality (post))
        \displayname "assign block"
    };

    assign_block {
        \find(\modality{#allmodal}{c# s#loc = {s#slist; s#e} #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# {s#slist; s#loc = s#e} #c}\endmodality (post))
        \displayname "assign block"
    };

    // ---- const block ---- //
    const_block {
        \find(\modality{#allmodal}{c# { const s#be } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#be #c}\endmodality (post))
    };

    // ---- if ---- //

    if_unfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# { let s#boolv : bool = s#nse; if s#boolv s#be0 } #c}\endmodality (post))
        \heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    if_else_unfold {
        \find(\modality{#allmodal}{c# if s#nse s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# { let s#boolv : bool = s#nse; if s#boolv s#be0 else s#be1 } #c}\endmodality (post))
        \heuristics(simplify_autoname)
        \displayname "ifElseUnfold"
    };

    if {
        \find(\modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be #c}\endmodality (post))
            \else(\modality{#allmodal}{c# () #c}\endmodality (post)))
        \displayname "ifElse"
    };

    if_else {
        \find(\modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith(\if(se = TRUE) \then(\modality{#allmodal}{c# s#be0 #c}\endmodality (post))
            \else(\modality{#allmodal}{c# s#be1 #c}\endmodality (post)))
        \heuristics(split_if)
        \displayname "ifElse"
    };

    if_else_split {
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post)) \add(se = FALSE ==>)
        \heuristics(split_if)
        \displayname "ifElseSplit"
    };

    if_split {
        \find( ==> \modality{#allmodal}{c# if s#se s#be  #c}\endmodality (post))
        "if se true":
            \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post)) \add(se = TRUE ==>);
        "if se false":
            \replacewith( ==> \modality{#allmodal}{c# () #c}\endmodality (post)) \add(se = FALSE ==>)
        \heuristics(split_if)
        \displayname "ifElseSplit"
    };

    if_true {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    if_else_true {
        \assumes(se = TRUE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be0 #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    if_false {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    if_else_false {
        \assumes(se = FALSE ==>)
        \find( ==> \modality{#allmodal}{c# if s#se s#be0 else s#be1 #c}\endmodality (post))
        \replacewith( ==> \modality{#allmodal}{c# s#be1 #c}\endmodality (post))
        \heuristics(simplify_prog)
    };

    // TODO: Are these last if rules above really useful?

    assign_if {
        \find(\modality{#allmodal}{c# s#loc = if s#e s#be0 else s#be1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# if s#e { s#loc = s#be0 } else { s#loc = s#be1 } #c}\endmodality (post))
        \heuristics(simplify_prog, split_if)
    };

    assign_if_simple_branches {
        \find(\modality{#allmodal}{c# s#loc = if s#se {s#se0} else {s#se1} #c}\endmodality (post))
        \replacewith({loc := \if(se = TRUE) \then(se0) \else(se1)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "condition"
    };

    assign_if_unfold {
        \find(\modality{#allmodal}{c# s#loc = if s#nse s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c#
            {
                let s#v0 : s#typeof(s#nse);
                s#v0 = s#nse;
                s#loc = if s#v0 s#be0 else s#be1
            } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "condition"
    };

    // ---- if let ---- //

    // Add ProgramSVSort for patterns so that unfolding can be done independent of pattern
    //ifLetUnfold {
    //    \find(\modality{#allmodal}{c# if let s#pat = s#nse s#be #c}\endmodality (post))
    //    \varcond(\newTypeOf(v0, nse))
    //    \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; if let s#pat = s#v0 s#be  #c}\endmodality (post))
    //};

    //ifLetElseUnfold {
    //    \find(\modality{#allmodal}{c# if let s#pat = s#nse s#be0 else s#be1 #c}\endmodality (post))
    //    \varcond(\newTypeOf(v0, nse))
    //    \replacewith(\modality{#allmodal}{c# let s#v0 : s#typeof(s#nse) = s#nse; if let s#pat = s#v0 s#be0 else s#be1 #c}\endmodality (post))
    //};

    if_let_range_exclusive {
        \find(\modality{#allmodal}{c# if let s#se0..s#se1 = s#se2 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 < s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    if_let_range_inclusive {
        \find(\modality{#allmodal}{c# if let s#se0..=s#se1 = s#se2 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 <= s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    if_let_range_from {
        \find(\modality{#allmodal}{c# if let s#se0.. = s#se1 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se1; if s#boolv s#be #c}\endmodality (post))
    };

    if_let_range_to_inclusive {
        \find(\modality{#allmodal}{c# if let ..=s#se0 = s#se1 s#be #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se1 <= s#se0; if s#boolv s#be #c}\endmodality (post))
    };

    if_let_range_exclusive_else {
        \find(\modality{#allmodal}{c# if let s#se0..s#se1 = s#se2 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# { let s#boolv : bool = s#se0 <= s#se2 && s#se2 < s#se1; if s#boolv s#be0 else s#be1 } #c}\endmodality (post))
    };

    if_let_range_inclusive_else {
        \find(\modality{#allmodal}{c# if let s#se0..=s#se1 = s#se2 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se2 && s#se2 <= s#se1; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    if_let_range_from_else {
        \find(\modality{#allmodal}{c# if let s#se0.. = s#se1 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se0 <= s#se1; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    if_let_range_to_inclusive_else {
        \find(\modality{#allmodal}{c# if let ..=s#se0 = s#se1 s#be0 else s#be1 #c}\endmodality (post))
        \varcond(\new(boolv, bool))
        \replacewith(\modality{#allmodal}{c# let s#boolv : bool = s#se1 <= s#se0; if s#boolv s#be0 else s#be1 #c}\endmodality (post))
    };

    // ---- Loop ---- //
    // See loopScopeRules.key

    // ---- match expr ---- //
    // TODO @ Nihal

    // ---- Unsafe block ---- //
    // TODO: How?

    // ---- Labeled Block ---- //
    // TODO

    // ---- Array Expression ---- //
    // ------ Enumerate ------ //
    // TODO

    // ------ Repeat ------ //
    assign_repeat_unfold_elem {
        \find(\modality{#allmodal}{c# s#loc = [s#nse; s#se] #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = [s#v; s#se] } #c}\endmodality (post))
    };

    assign_repeat {
        \find(\modality{#allmodal}{c# s#loc = [s#se0; s#se1] #c}\endmodality (post))
        \varcond(\hasSort(se0, \sort(El)), \sub(\typeof(se1), \sort(int)))
        \replacewith({loc := arr_repeat<[El, const se1]>(se0)}\modality{#allmodal}{c# () #c}\endmodality (post))
    };

    // ---- Break ---- //
    // See loop rules / labeled block rules

    break_label_unfold {
        \find(\modality{#allmodal}{c# break s#lbl s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse); break s#lbl s#v } #c}\endmodality (post))
    };

    break_unfold {
        \find(\modality{#allmodal}{c# break s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse); break s#v } #c}\endmodality (post))
    };

    break_label_unlabeled_block {
        \find(\modality{#allmodal}{c# { break s#lbl; s#slist } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# break s#lbl #c}\endmodality (post))
    };

    break {
        \find(\modality{#allmodal}{c# { break; s#slist } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# () #c}\endmodality (post))
    };

    break_value_label_unlabeled_block {
        \find(\modality{#allmodal}{c# { break s#lbl s#se; s#slist } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# break s#lbl s#se #c}\endmodality (post))
        \displayname "break"
    };

    break_value {
        \find(\modality{#allmodal}{c# { break s#se; s#slist } #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#se #c}\endmodality (post))
        \displayname "break"
    };

    // ---- Call ---- //
    // TODO

    // ---- Closure ---- //
    // TODO

    // ---- Continue ---- //
    // See loop rules

    // ---- Field expr ---- //
    // TODO

    // ---- Index expr ---- //

    index_assign_unfold_indexed {
        \find(\modality{#allmodal}{c# s#nse[s#e] = s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#v[s#e] = s#se } #c}\endmodality (post))
    };

    index_assign_unfold_index {
        \find(\modality{#allmodal}{c# s#se0[s#nse] = s#se1 #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#se0[s#v] = s#se1 } #c}\endmodality (post))
    };

    // TODO: rework once we use index traits
    array_index_assign {
        \schemaVar \term int N;
        \schemaVar \program RustUsizeExpression idx;
        \find(\modality{#allmodal}{c# s#loc[s#idx] = s#se #c}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(se, \sort(El)), \hasSort(loc, \sort(Array<[El, const N]>)))
        "Normal execution":
            \replacewith({loc := arr_set<[El, const N]>(loc, idx, se)}\modality{#allmodal}{c# () #c}\endmodality (post))
            \add(N > idx ==>);
        "s#idx out of bounds":
            \replacewith(\modality{#allmodal}{c# panic!() #c}\endmodality (post))
            \add(!(N > idx) ==>)
    };

    assign_index_unfold_indexed {
        \find(\modality{#allmodal}{c# s#loc = s#nse[s#e] #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v[s#e] } #c}\endmodality (post))
    };

    assign_index_unfold_index {
        \find(\modality{#allmodal}{c# s#loc = s#se[s#nse] #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#se[s#v] } #c}\endmodality (post))
    };

    // TODO: rework once we use index traits
    assign_array_index {
        \schemaVar \term int N;
        \schemaVar \program RustUsizeExpression idx;
        \find(\modality{#allmodal}{c# s#loc = s#se[s#idx] #c}\endmodality (post))
        \sameUpdateLevel
        \varcond(\hasSort(loc, \sort(El)), \hasSort(se, \sort(Array<[El, const N]>)))
        "Normal execution":
            \replacewith({loc := arr_get<[El, const N]>(se, idx)}\modality{#allmodal}{c# () #c}\endmodality (post))
            \add(N > idx ==>);
        "s#idx out of bounds":
            \replacewith(\modality{#allmodal}{c# panic!() #c}\endmodality (post))
            \add(!(N > idx) ==>)
    };

    // ---- Literal expr ---- //
    // Nothing to do

    // ---- Method call ---- //
    // TODO

    // ---- Operator expr ---- //

    // ------ Arithmetic ------ //

    // -------- Addition -------- //

    assign_addition_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse + s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v + s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "addition"
    };

    assign_addition_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e + s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 + s#v1; }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "addition"
    };

    // -------- Division -------- //

    assign_division_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse / s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v / s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "division"
    };

    assign_division_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e / s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 / s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "multiplication"
    };

    // -------- Multiplication -------- //

    assign_multiplication_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse * s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v * s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "multiplication"
    };

    assign_multiplication_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e * s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 * s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "multiplication"
    };

    // -------- Remainder -------- //

    assign_remainder_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse % s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v % s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "modulo"
    };

    assign_remainder_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e % s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 % s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "modulo"
    };

    // -------- Subtraction -------- //

    assign_subtraction_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse - s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v - s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "subtraction"
    };

    assign_subtraction_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e - s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e = s#v0 - s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "subtraction"
    };

    // ------ Assignment ------ //

    assignment_unfold {
        \find(\modality{#allmodal}{c# s#nse0 = s#nse1 #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse1))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse1) = s#nse1; s#nse0 = s#v } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "addition"
    };

    // TODO: make to copy rule
    assignment {
        \find(\modality{#allmodal}{c# s#loc = s#se #c}\endmodality (post))
        \replacewith({loc := se}\modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog, simplify_prog_subset)
    };

    // ------ Bitwise ------ //

    // -------- And -------- //
    assign_bitwise_and_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse & s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v & s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "bitwise and"
    };

    assign_bitwise_and_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e & s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 & s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "bitwise and"
    };

    // -------- Or -------- //
    assign_bitwise_or_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse | s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v | s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "bitwiseOr"
    };

    assign_bitwise_or_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e | s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 | s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "multiplication"
    };

    // -------- Xor -------- //
    assign_bitwise_xor_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse ^ s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v ^ s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "bitwiseXor"
    };

    assign_bitwise_xor_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e ^ s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 ^ s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "bitwiseXor"
    };

    // -------- Shl -------- //
    assign_shl_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse << s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v << s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shist left"
    };

    assign_shl_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e << s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 << s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift left"
    };

    // -------- Shr -------- //
    assign_shr_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse >> s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v >> s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift right"
    };

    assign_shr_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e >> s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 >> s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "shift right"
    };

    // ------ Borrow ------ //

    assign_shared_borrow_unfold {
        \find(\modality{#allmodal}{c# s#loc = &s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = &s#v } #c}\endmodality (post))
        \displayname "borrow shared"
    };

    assign_shared_borrow {
        \find(\modality{#allmodal}{c# s#loc = &s#a #c}\endmodality (post))
        \varcond(\hasSort(a, \sort(S)))
        \replacewith({loc := refS<[S]>(a)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \displayname "borrow shared"
    };

    assign_mut_borrow_unfold {
        \find(\modality{#allmodal}{c# s#loc = &mut s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = &mut s#v } #c}\endmodality (post))
        \displayname "borrow mut"
    };

    assign_mut_borrow {
        \find(\modality{#allmodal}{c# s#loc = &mut s#a #c}\endmodality (post))
        \varcond(\hasSort(a, \sort(S)))
        \replacewith({loc := refM<[S]>(pvToPlace(a))}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \displayname "borrow mut"
    };

    // ------ Comparison ------ //

    // -------- Equality -------- //
    assign_equality_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse == s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v == s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality"
    };

    assign_equality_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e == s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#e0 = s#v0 == s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality"
    };

    assign_equality {
        \find(\modality{#allmodal}{c# s#loc = s#se0 == s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(se0 = se1) \then(TRUE) \else(FALSE)}
        \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "equality"
    };

    // -------- Greater than -------- //
    assign_greater_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse > s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v > s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater than"
    };

    assign_greater_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e1 > s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e1), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 > s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater than"
    };

    assign_greater {
        \find(\modality{#allmodal}{c# s#loc = s#se0 > s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(gt(se0, se1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater than distinction"
    };

    // -------- Greater or equal -------- //
    assign_greater_equal_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse >= s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#e0=s#v >= s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater or equal"
    };

    assign_greater_equal_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e >= s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 >= s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater or equal"
    };

    assign_greater_equal {
        \find(\modality{#allmodal}{c# s#loc = s#se0 >= s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(geq(se0, se1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "greater-or-equal than distinction"
    };

    // -------- Less than -------- //
    assign_less_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse < s#se; #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v < s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less than"
    };

    assign_less_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e < s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 < s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less than"
    };

    assign_less {
        \find(\modality{#allmodal}{c# s#loc = s#se0 < s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(lt(se0, se1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less than distinction"
    };

    // -------- Less than or equal -------- //
    assign_less_equal_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse <= s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v <= s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less or equal"
    };

    assign_less_equal_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e <= s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 <= s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less or equal"
    };

    assign_less_equal {
        \find(\modality{#allmodal}{c# s#loc = s#se0 <= s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(leq(se0, se1)) \then(TRUE) \else(FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "less-or-equal than distinction"
    };

    // -------- Inequality -------- //
    assign_inequality_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nse != s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v != s#se } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality"
    };

    assign_inequality_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#e != s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, e), \newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# {
            let s#v0 : s#typeof(s#e) = s#e;
            let s#v1 : s#typeof(s#nse) = s#nse;
            s#loc = s#v0 != s#v1 }
        #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality"
    };

    assign_inequality {
        \find(\modality{#allmodal}{c# s#loc = s#se0 != s#se1 #c}\endmodality (post))
        \replacewith({loc := \if(se0 = se1) \then(FALSE) \else(TRUE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "inequality comparison"
    };

    // ------ Compound assignment ------ //
    // TODO: rework w/ trait call

    compound_assign_addition {
        \find(\modality{#allmodal}{c# s#e0 += s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 + s#e1 #c}\endmodality (post))
    };

    compound_assign_and {
        \find(\modality{#allmodal}{c# s#e0 &= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 & s#e1 #c}\endmodality (post))
    };

    compound_assign_or {
        \find(\modality{#allmodal}{c# s#e0 |= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 | s#e1 #c}\endmodality (post))
    };

    compound_assign_xor {
        \find(\modality{#allmodal}{c# s#e0 ^= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 ^ s#e1 #c}\endmodality (post))
    };

    compound_assign_division {
        \find(\modality{#allmodal}{c# s#e0 /= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 / s#e1 #c}\endmodality (post))
    };

    compound_assign_multiplication {
        \find(\modality{#allmodal}{c# s#e0 *= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 * s#e1 #c}\endmodality (post))
    };

    compound_assign_remainder {
        \find(\modality{#allmodal}{c# s#e0 %= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 % s#e1 #c}\endmodality (post))
    };

    compound_assign_shl {
        \find(\modality{#allmodal}{c# s#e0 <<= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 << s#e1 #c}\endmodality (post))
    };

    compound_assign_shr {
        \find(\modality{#allmodal}{c# s#e0 >>= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 >> s#e1 #c}\endmodality (post))
    };

    compound_assign_subtraction {
        \find(\modality{#allmodal}{c# s#e0 -= s#e1 #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#e0 = s#e0 - s#e1 #c}\endmodality (post))
    };

    // ------ Deref ------ //

    deref_assign_unfold_left {
        \find(\modality{#allmodal}{c# *s#nse = s#se #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; *s#v = s#se } #c}\endmodality (post))
    };

    assign_deref_unfold {
        \find(\modality{#allmodal}{c# s#loc = *s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = *s#v } #c}\endmodality (post))
    };

    assign_deref_shared {
        \find(\modality{#allmodal}{c# s#loc0 = *s#loc1 #c}\endmodality (post))
        \varcond(\hasSort(loc1, \sort(SRef<[S]>)))
        \replacewith({loc0 := derefS<[S]>(loc1)}\modality{#allmodal}{c# () #c}\endmodality (post))
    };

    assign_deref_mut {
        \find(\modality{#allmodal}{c# s#loc0 = *s#loc1 #c}\endmodality (post))
        \varcond(\hasSort(loc1, \sort(MRef<[S]>)))
        \replacewith({loc0 := derefM<[S]>(loc1)}\modality{#allmodal}{c# () #c}\endmodality (post))
    };

    deref_assign {
        \find(\modality{#allmodal}{c# *s#a = s#se #c}\endmodality (post))
        \replacewith({a *-> se}
            \modality{#allmodal}{c# () #c}\endmodality (post))
    };

    // ------ Lazy boolean ------ //

    // -------- And -------- //
    assign_lazy_and_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#exBool && s#nseBool #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#loc = if !s#exBool { false } else { s#nseBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "and"
    };

    assign_lazy_and_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nseBool && s#seBool #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# { let s#v : bool = s#nseBool; s#loc = s#v && s#seBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "and"
    };

    assign_lazy_and {
        \find(\modality{#allmodal}{c# s#loc = s#seBool0 && s#seBool1 #c}\endmodality (post))
        \replacewith({loc := \if(seBool0 = TRUE & seBool1 = TRUE) \then(TRUE) \else (FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "and"
    };

    // -------- Or -------- //
    assign_lazy_or_unfold_left_and_right {
        \find(\modality{#allmodal}{c# s#loc = s#exBool || s#nseBool #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#loc = if s#exBool { true } else { s#nseBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "or"
    };

    assign_lazy_or_unfold_left {
        \find(\modality{#allmodal}{c# s#loc = s#nseBool || s#seBool #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# { let s#v : bool = s#nseBool; s#loc = s#v || s#seBool } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "or"
    };

    assign_lazy_or {
        \find(\modality{#allmodal}{c# s#loc = s#seBool0 || s#seBool1 #c}\endmodality (post))
        \replacewith({loc := \if(seBool0 = TRUE | seBool1 = TRUE) \then(TRUE) \else (FALSE)}
            \modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "or"
    };

    // ------ Negation ------ //

    // -------- Bitwise -------- //
    assign_bitwise_negation {
        \find(\modality{#allmodal}{c# s#loc = !s#seBool #c}\endmodality (post))
        \replacewith({loc := \if(seBool = TRUE) \then(FALSE) \else(TRUE)}\modality{#allmodal}{c# () #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "negation"
    };

    assign_bitwise_negation_unfold {
        \find(\modality{#allmodal}{c# s#loc = !s#nseBool #c}\endmodality (post))
        \varcond(\new(v, bool))
        \replacewith(\modality{#allmodal}{c# { let s#v : bool = s#nseBool; s#loc = !s#v } #c}\endmodality (post))
        \heuristics(simplify_expression)
        \displayname "negation"
    };

    // -------- Sign -------- //
    // TODO

    // ------ Raw borrow ------ //
    // TODO

    // ------ Cast ------ //

    assign_cast_unfold {
        \find(\modality{#allmodal}{c# s#loc = s#nse as s#t #c}\endmodality (post))
        \varcond(\newTypeOf(v, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v : s#typeof(s#nse) = s#nse; s#loc = s#v as s#t } #c}\endmodality (post))
    };

    // TODO

    // ---- Path expr ---- //
    // Nothing to do
    // TODO: Unit structs, enums?

    // ---- Return ---- //

    return_unfold {
        \find(\modality{#allmodal}{c# return s#nse #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v0: s#typeof(s#nse) = s#nse; return s#v0 } #c}\endmodality (post))
        \heuristics(simplify_prog)
        \displayname "returnUnfold"
    };

    function_body_expand {
        \find(\modality{#allmodal}{c# s#fb; #c}\endmodality (post))
        \replacewith(introAtPreDefs(\modality{#allmodal}{c# s#expand_fn_body(s#fb); #c}\endmodality (post)))
        \heuristics(simplify_prog)
    };

    empty_frame {
        \find(\modality{#allmodal}{c# fn_frame!(s#v0, {}) #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#v0 = () #c}\endmodality (post))
    };

    implicit_return {
        \find(\modality{#allmodal}{c# fn_frame!(s#v0, {s#se}) #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# s#v0 = s#se #c}\endmodality (post))
    };

    implicit_return_unfold {
        \find(\modality{#allmodal}{c# fn_frame!(s#v0, {s#nse}) #c}\endmodality (post))
        \varcond(\newTypeOf(v1, nse))
        \replacewith(\modality{#allmodal}{c# fn_frame!(s#v0, { let s#v1 = s#nse; s#v1 }) #c}\endmodality (post))
    };

    // ---- Struct expr ---- //
    // TODO

    // ---- Tuple expr ---- //

    assign_tuple_unfold {
        \find(\modality{#allmodal}{c# s#loc = (s#selist, s#nse, s#elist) #c}\endmodality (post))
        \varcond(\newTypeOf(v0, nse))
        \replacewith(\modality{#allmodal}{c# { let s#v0 : s#typeof(s#nse) = s#nse; s#loc = (s#selist, s#v0, s#elist) } #c}\endmodality (post))
    };

    assign_tuple {
        \find(\modality{#allmodal}{c# s#loc = (s#selist,); #c}\endmodality (post))
        \replacewith({loc := toTuple(selist)}\modality{#allmodal}{c# () #c}\endmodality (post))
    };

    // Statements

    simple_expr_stmt {
        \find(\modality{#allmodal}{c# s#se; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
    };

    // ---- let stmt ---- //

    let_ident_pat {
        \find(\modality{#allmodal}{c# let s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    let_ident_pat_no_type {
        \find(\modality{#allmodal}{c# let s#v0; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    let_ident_pat_mut {
        \find(\modality{#allmodal}{c# let mut s#v0 : s#t; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    let_ident_pat_mut_no_type {
        \find(\modality{#allmodal}{c# let mut s#v0; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# #c}\endmodality (post))
        \addprogvars(v0)
        \displayname "let"
    };

    let_ident_pat_assign {
        \find(\modality{#allmodal}{c# let s#p : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let s#p : s#t; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    let_ident_pat_assign_no_type {
        \find(\modality{#allmodal}{c# let s#p = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let s#p; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    let_ident_pat_assign_mut {
        \find(\modality{#allmodal}{c# let mut s#p : s#t = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let mut s#p : s#t; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };

    let_ident_pat_assign_mut_no_type {
        \find(\modality{#allmodal}{c# let mut s#p = s#e; #c}\endmodality (post))
        \replacewith(\modality{#allmodal}{c# let mut s#p; s#p = s#e; #c}\endmodality (post))
        \displayname "let"
    };
}
